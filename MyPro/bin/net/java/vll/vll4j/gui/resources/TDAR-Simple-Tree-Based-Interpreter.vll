<?xml version="1.0"?>

<!-- *****************  Do not edit  ***************** -->
<!-- Generated by VisualLangLab (http://vll.java.net/) -->
<!-- *****************  Do not edit  ***************** -->
<VLL-Grammar>
  <Tokens>
    <Literal Name="&quot;%&quot;" Pattern="%" />
    <Literal Name="&quot;(&quot;" Pattern="(" />
    <Literal Name="&quot;)&quot;" Pattern=")" />
    <Literal Name="&quot;*&quot;" Pattern="*" />
    <Literal Name="&quot;+&quot;" Pattern="+" />
    <Literal Name="&quot;-&quot;" Pattern="-" />
    <Literal Name="&quot;/&quot;" Pattern="/" />
    <Literal Name="&quot;=&quot;" Pattern="=" />
    <Regex Name="ID" Pattern="[a-zA-Z]+" />
    <Regex Name="INT" Pattern="\\d+" />
    <Regex Name="NEWLINE" Pattern="\\r?\\n" />
  </Tokens>
  <Whitespace>[ \\t]+</Whitespace>
  <Comments></Comments>
  <Parsers>
    <Parser Name="Prog" >
      <Reference Ref="stat" Mult="+" ActionText="function(x) {&#xA;&#xA;  if (x === null) {&#xA;&#xA;    vllMemory = {};&#xA;    functionConstants = {};&#xA;    functionFormulae = {};&#xA;&#xA;  functionCall = function(id, e) {&#xA;    var argValue = exprHdlr(e);&#xA;    var fcKey = [id, argValue];&#xA;    if (functionConstants.hasOwnProperty(fcKey)) {&#xA;      return functionConstants[fcKey];&#xA;    } else if (functionFormulae.hasOwnProperty(id)) {&#xA;      var p = functionFormulae[id];&#xA;      var arg2 = p[0];&#xA;      var expr = p[1];&#xA;      var oldVal = null;&#xA;      if (vllMemory.hasOwnProperty(arg2)) {&#xA;        oldVal = vllMemory[arg2];&#xA;      }&#xA;      vllMemory[arg2] = argValue;&#xA;      var retVal = exprHdlr(expr);&#xA;      if (oldVal === null) {&#xA;        delete vllMemory.arg2;&#xA;      } else {&#xA;        vllMemory[arg2] = oldVal;&#xA;      }&#xA;      return retVal;&#xA;    } else {&#xA;      println(&quot;undefined function: &quot; + id);&#xA;      return 0;&#xA;    }&#xA;  }&#xA;&#xA;  functionHdlr = function(f) {&#xA;    var id = f[0];&#xA;    var fp = f[1];&#xA;    var e = f[2];&#xA;    switch (fp[0].intValue()) {&#xA;      case 0: functionFormulae[id] = [fp[1], e];&#xA;        break;&#xA;      case 1: functionConstants[[id, parseInt(fp[1])]] = exprHdlr(e);&#xA;        break;&#xA;    }&#xA;  }&#xA;&#xA;  atomHdlr = function(atom) {&#xA;    switch (atom[0].intValue()) {&#xA;      case 0: var arr = atom[1];&#xA;        return functionCall(arr[0], arr[1]);&#xA;        break;&#xA;      case 1: return exprHdlr(atom[1]);&#xA;        break;&#xA;      case 2: return parseInt(atom[1]);&#xA;        break;&#xA;      case 3: &#xA;        if (vllMemory.hasOwnProperty(atom[1])) {&#xA;          return vllMemory[atom[1]];&#xA;        } else {&#xA;          println(&quot;Undefined: &quot; + atom[1]);&#xA;          return 0;&#xA;        }&#xA;    }&#xA;  }&#xA;&#xA;  multExprHdlr = function(mxpr) {&#xA;    var result = atomHdlr(mxpr[0]);&#xA;    var lst = mxpr[1];&#xA;    for (var i = 0; i &lt; lst.size(); ++i) {&#xA;      var arr = lst.get(i);&#xA;      switch (arr[0][0].intValue()) {&#xA;          case 0: result *= atomHdlr(arr[1]);&#xA;            break;&#xA;          case 1: result /= atomHdlr(arr[1]);&#xA;            break;&#xA;          case 2: result %= atomHdlr(arr[1]);&#xA;            break;&#xA;      }&#xA;    }&#xA;    return result;&#xA;  }&#xA;&#xA;  exprHdlr = function(expr) {&#xA;    var result = multExprHdlr(expr[0]);&#xA;    var lst = expr[1];&#xA;    for (var i = 0; i &lt; lst.size(); ++i) {&#xA;      var arr = lst.get(i);&#xA;      switch (arr[0][0].intValue()) {&#xA;          case 0: result += multExprHdlr(arr[1]);&#xA;            break;&#xA;          case 1: result -= multExprHdlr(arr[1]);&#xA;            break;&#xA;      }&#xA;    }&#xA;    return result;&#xA;  }&#xA;&#xA;  statHdlr = function(statement) {&#xA;    switch (statement[0].intValue()) {&#xA;      case 0: var arr = statement[1];&#xA;        vllMemory[arr[0]] = exprHdlr(arr[1]);&#xA;        break;&#xA;      case 1: functionHdlr(statement[1]);&#xA;        break;&#xA;      case 2: println(exprHdlr(statement[1]));&#xA;        break;&#xA;      case 3: // do nothing&#xA;        break;&#xA;    }&#xA;  }&#xA;&#xA;  progHdlr = function(listOfStatements) {&#xA;    for (var i = 0; i &lt; listOfStatements.size(); ++i) {&#xA;      statHdlr(listOfStatements.get(i));&#xA;    }&#xA;  }&#xA;&#xA;  } else {&#xA;    progHdlr(x);&#xA;  }&#xA;}" />
    </Parser>
    <Parser Name="atom" >
      <Choice >
        <Sequence >
          <Token Ref="ID" />
          <Token Ref="&quot;(&quot;" Drop="true" />
          <Reference Ref="expr" />
          <Token Ref="&quot;)&quot;" Drop="true" />
        </Sequence>
        <Sequence >
          <Token Ref="&quot;(&quot;" Drop="true" />
          <Reference Ref="expr" />
          <Token Ref="&quot;)&quot;" Drop="true" />
        </Sequence>
        <Token Ref="INT" />
        <Token Ref="ID" />
      </Choice>
    </Parser>
    <Parser Name="expr" >
      <Sequence >
        <Reference Ref="multExpr" />
        <Sequence Mult="*" >
          <Choice >
            <Token Ref="&quot;+&quot;" />
            <Token Ref="&quot;-&quot;" />
          </Choice>
          <Reference Ref="multExpr" />
        </Sequence>
      </Sequence>
    </Parser>
    <Parser Name="formalPar" >
      <Choice >
        <Token Ref="ID" />
        <Token Ref="INT" />
      </Choice>
    </Parser>
    <Parser Name="func" >
      <Sequence >
        <Token Ref="ID" />
        <Token Ref="&quot;(&quot;" Drop="true" />
        <Reference Ref="formalPar" />
        <Token Ref="&quot;)&quot;" Drop="true" />
        <Token Ref="&quot;=&quot;" Drop="true" />
        <Reference Ref="expr" />
      </Sequence>
    </Parser>
    <Parser Name="multExpr" >
      <Sequence >
        <Reference Ref="atom" />
        <Sequence Mult="*" >
          <Choice >
            <Token Ref="&quot;*&quot;" />
            <Token Ref="&quot;/&quot;" />
            <Token Ref="&quot;%&quot;" />
          </Choice>
          <Reference Ref="atom" />
        </Sequence>
      </Sequence>
    </Parser>
    <Parser Name="stat" >
      <Choice >
        <Sequence >
          <Token Ref="ID" />
          <Token Ref="&quot;=&quot;" Drop="true" />
          <Reference Ref="expr" />
          <Token Ref="NEWLINE" Drop="true" />
        </Sequence>
        <Sequence >
          <Reference Ref="func" />
          <Token Ref="NEWLINE" Drop="true" />
        </Sequence>
        <Sequence >
          <Reference Ref="expr" />
          <Token Ref="NEWLINE" Drop="true" />
        </Sequence>
        <Token Ref="NEWLINE" />
      </Choice>
    </Parser>
  </Parsers>
</VLL-Grammar>
